# [17070] 파이프 옮기기 1 - Java

## :pushpin: **Algorithm**

DP (동적 계획법), 그래프 이론

## :round_pushpin: **Logic**

```java
for (int i = 0; i < N; i++) {
  for (int j = 2; j < N; j++) {
    if (ary[i][j] == 1) continue;
    dp[i][j][0] = dp[i][j-1][0] + dp[i][j-1][1];

    if (i == 0) continue;
    dp[i][j][2] = dp[i-1][j][1] + dp[i-1][j][2];

    if (ary[i-1][j] == 1 || ary[i][j-1] == 1) continue;
    dp[i][j][1] = dp[i-1][j-1][0] + dp[i-1][j-1][1] + dp[i-1][j-1][2];
  }
}
return dp[N-1][N-1][0] + dp[N-1][N-1][1] + dp[N-1][N-1][2];
```

- ```dp[i][j][k]``` 에서 각 인덱스는 x, y 좌표와 파이프의 모양을 의미하고, ```dp[0][1][0] = 1``` 이라면, (0,1)에 가로 파이프의 끝 지점이 위치해있음을 의미
- 파이프가 가로인 경우에는 그 직전의 모양이 가로이거나, 대각선일 경우
- 파이프가 세로인 경우에는 그 직전의 모양이 세로이거나, 대각선일 경우
- 파이프가 대각선인 경우에는 그 직전의 모양이 가로, 세로, 대각선일 경우

## :black_nib: **Review**

- 처음에는 ```Position``` Class를 생성해서 파이프 끝지점의 ```x```, ```y```좌표와 가로, 세로, 대각선 정보를 저장하는 ```s``` 변수를 저장하고, ```queue```를 이용해서 각 모양마다 확인해야 할 자리를 확인하고 경우의 수를 계속 더하여 최종 ```dp[N-1][N-1]```에서의 값을 확인하도록 했는데, 마지막 테스트케이스에서 동작하지 않아서 포기
- 다른 풀이를 참고하여 해결 ..