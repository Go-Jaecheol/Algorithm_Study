# [17070] 파이프 옮기기 1 - Python

## :mag: Algorithm

Dynamic Programming

## :round_pushpin: Logic

- 모든 원소의 값이 0인 **N _ N _ 3** 크기의 3차원 배열 dp를 생성한다.

  > dp[i][j]의 인덱스 0은 파이프가 가로인 상태, 1은 파이프가 세로인 상태, 2는 파이프가 대각선인 상태를 뜻하며, 각 값은 (i, j) 위치까지 파이프가 올 수 있는 경우의 수를 가리킨다.

  가창 처음 파이프의 위치에 따라 `dp[0][1][0] = 1` 로 설정한다.

<br />

- 2중 반복문으로 (파이프가 이동하지 않는 불필요한 계산을 제외하기 위해 `j < 2` 인 경우는 배제한다.) 아래 경우들을 통해 3차원 배열 dp의 값들을 업데이트한다.

  <br />

  - 만약 집의 위치 `home[i][j]`가 0일 때,

    - (i, j) 위치에 파이프가 가로로 놓일 경우

      ```python
      dp[i][j][0] = dp[i][j-1][0] + dp[i][j-1][2]
      ```

    - (i, j) 위치에 파이프가 세로로 놓일 경우

      ```python
      dp[i][j][1] = dp[i-1][j][1] + dp[i-1][j][2]
      ```

    <br />

  - 만약 집의 위치 `home[i][j]`가 0인 것과 더불어, `home[i-1][j]`와 `home[i][j-1]` 또한 0일 때,

    - (i, j) 위치에 파이프가 대각선으로 놓일 경우

      ```python
      dp[i][j][2] = sum(dp[i-1][j-1])
      ```

      <br />

  아래 코드는 위 내용들을 포함하고 있다.

  ```python
  for i in range(N):
      for j in range(2, N):
          if home[i][j] == 0:
              dp[i][j][0] = dp[i][j-1][0] + dp[i][j-1][2]
              dp[i][j][1] = dp[i-1][j][1] + dp[i-1][j][2]
              if home[i-1][j] == 0 and home[i][j-1] == 0:
                  dp[i][j][2] = sum(dp[i-1][j-1])
  ```

<br />

- 위 2중 반복문이 종료되면 `dp[-1][-1]`의 가로, 세로, 대각선으로 파이프가 놓이는 경우의 수를 합한 결과를 출력한다.
  ```python
  print(sum(dp[-1][-1]))
  ```

## :memo: Review

문제에 친절하게 파이프가 놓일 수 있는 경우의 수를 그림으로 표현해주었고, 이를 통해 아이디어를 떠올리는 것은 어렵지 않았다.

아이디어를 코드로 구현하는 것에 있어 고민을 하다, 결국 3차원 배열을 이용하기로 했고 문제를 한번에 해결할 수 있었다.

3차원 배열은 되도록이면 사용하고 싶지 않았지만, 3개의 원소를 가진 3차원 배열이므로 사용할만 하겠다고 생각했다. 

사실 마땅히 다른 방안이 떠오르지 않았다...


