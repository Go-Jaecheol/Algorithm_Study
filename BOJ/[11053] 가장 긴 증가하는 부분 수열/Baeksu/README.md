# [11053] 가장 긴 증가하는 부분 수열 - C ++

## :pushpin: **Algorithm**

DP (동적 계획법)

## :round_pushpin: **Logic**

```c++
int* dp;
```

- 배열의 각 숫자를 포함하는 증가하는 부분 수열의 길이을 저장하는 배열

```c++
if ((arr[i] > arr[j]) && (dp[i] <= dp[j])) {
	dp[i] = dp[j] + 1;
}
```

- 먼저 나온 수보다 뒤에 있는 수가 큰 경우 + 먼저 나온 수에 해당하는 dp값이 뒤에 있는 수의 dp값보다 큰 경우
  - 즉 증가하는 부분 수열이므로 dp값 증가

```c++
sort(dp, dp + N);

cout << dp[N - 1];
```

- dp 배열 오름차순 정렬하고 마지막 값 출력

## :black_nib: **Review**

- 처음 아이디어는 이 문제가 왜 dp인지 의문이 들게끔 잡았음
- 눈에 딱 떨어지는 점화식은 없는 것 같아서 머리 깨지는 줄 알았음
- 5
  1 5 2 3 4 같은 반례 이용하여 아이디어 전체를 수정
- 아직 DP는 not easy ...

