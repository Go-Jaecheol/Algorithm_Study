# [9251] LCS - Python

## :mag: Algorithm
**Dynamic Programming**

## :computer: Logic
### `Bottom-up`
- 문자열 A와 B에서 **중복되는 문자가 나타나는 경우**를  
이차원 리스트 `dp[row][col]`로 나타낸다.  
ex)  
테스트 케이스  
***ACAYKP***  
***CAPCAK***  
의 경우에는  
> 0 1 0 0 1 0  
> 1 0 0 1 0 0  
> 0 1 0 0 1 0  
> 0 0 0 0 0 0  
> 0 0 0 0 0 1  
> 0 0 1 0 0 0  

이런 식으로 나타낼 수 있다.

하지만 단순히 이렇게 나타내면 LCS의 길이를 찾기 힘드므로  
다음 과정을 거친다.

- 예를 들어 위 테스트 케이스에서 기준이 되는 문자가  
> 0 1 0 0 1 0  
> 1 0 0 ***1*** 0 0  
> 0 1 0 0 1 0  
> 0 0 0 0 0 0  
> 0 0 0 0 0 1  
> 0 0 1 0 0 0  

`dp[1][3]`이라고 하면 해당 문자가 마지막 문자가 되는 **LCS**는  
`dp[0][1]+dp[1][3]`이 된다.

여기서 알 수 있는 점은 **중복되는 문자 `dp[i][j]`가 나타나는 경우**에는  
**i-1 라인**에 **(0 ~ j-1)** 에 해당하는 dp 값들 중 **제일 큰 값**을  
`dp[i][j]`에 더해서 dp 값을 **업데이트** 하면 된다.  
**`(-> dp[i][j] = dp[i][j] + max(dp[i-1][0:j]))`**

하지만 이렇게 하면 max 값을 구하는 과정까지 하면 **시간초과**가 나기 때문에  
`max(dp[i-1][0:j])`를 구하는 과정을 다르게 생각해야 한다.

- 위에서는 중복되는 문자가 있는 경우 `(A[i] == B[j])`에만 dp 값을 업데이트 했는데  
아닌 경우 `(else)`에도 dp 값을 업데이트 하도록 하면  
위에서 구하는 max 값을 쉽게 구할 수 있다.

간단하게 문자가 중복되지 않는 경우에는 이차원 배열에서  
해당 인덱스 **왼쪽(dp[row][col-1])과 바로 위(dp[row-1][col])의 값** 중 **큰 값**으로  
dp를 업데이트 하면 된다.  
**`(-> dp[row][col] = max(dp[row][col-1], dp[row-1][col]))`**

- 지금까지 과정을 종합하면 아래와 같은 식이 나온다.
```Python
if(A[i] == B[j]):
  dp[row][col] = dp[row-1][col-1] + 1
else:
  dp[row][col] = max(dp[row][col-1], dp[row-1][col])
```

여기서 인덱스가 0일 때 계산을 하려면  
이차원 리스트 dp에 0번째 인덱스들을 추가로 더 만들어주고  
인덱스가 1일 때부터 계산을 해야 한다.

그러면 다음과 같은 코드가 나오게 된다.  
```Python
dp = [[0 for x in range(len(B)+1)]for y in range(len(A)+1)]

for i in range(len(A)):
  row = i + 1
  for j in range(len(B)):
    col = j + 1
    if(A[i] == B[j]):
      dp[row][col] = dp[row-1][col-1] + 1
    else:
      dp[row][col] = max(dp[row][col-1], dp[row-1][col])
```

## :memo: Review
처음에는 간단한 방법이 생각나서 했지만  
역시나 시간초과가 났다.

그 다음에는 점화식 찾고 풀이 방법은 쉽게 찾았는데  
계속 통과가 안됐다..  
다른 블로그에서 테스트 케이스 찾아서 다 해봐도  
다 통과하는데 백준만 안되길래  
그냥 넘길까 하다가  

이차원 배열에 인덱스 0을 추가하는 방법이 있어서 했더니  
바로 통과하네,,,,,, 하

아직 생각이 짧다

