# [1491] 도서관
## 💡Algorithm
- 그리디 알고리즘
- 정렬
## 📚Logic
문제를 4가지 경우로 나눌 수 있다.

-  모두 양수일 때
- 모두 음수일 때
- 음수의 절댓값의 최대가 양수의 최댓값보다 보다 클 때
- 음수의 절댓값의 최대가 양수의 최댓값보다 작을 때

걸음의 수는 구하기 쉽다. 편하게 구하기 위해 양수와 음수 따로 구한다.

절댓값이 큰 순서대로 정렬한 후, 첫번째 수 부터 m의 크기만큼 묶어서 (묶음에서 제일 큰 수 * 2)를 모두 더하면 최소 발걸음을 구할 수 있다. 여기서 차이점은 첫번째 묶음을 두배해서 더하는가 그냥 더하는가의 차이다.
```c++
int get_step(vector<int> input, int w) {
    int res = 0, count = 0;
    res += (abs(input[0]) * w);//w가 1이면 첫번째를 그냥 더하고, 2이면 두배한 후 더한다.
    for (int i = 0; i < input.size(); i++) {
        if (count == m) {
            count = 0;
            res = res + (abs(input[i]) * 2);
        }
        count++;
    }
    return res;
}
```
## 📝Review
어렵지 않게 풀었다. 문제는 그리디는 재미가 없다는 것이다. 그래프, DP 꿀잼!
